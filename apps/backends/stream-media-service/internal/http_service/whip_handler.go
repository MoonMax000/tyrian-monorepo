package http_service

import (
	"io"
	"net/http"

	"github.com/Capstane/stream-media-service/internal/translation"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
	"github.com/rs/zerolog/log"
)

type WhipHandler struct {
	translationManager translation.TranslationControl
	settingEngine      *webrtc.SettingEngine
}

func NewWhipHandler(translationManager translation.TranslationControl, settingEngine *webrtc.SettingEngine) http.Handler {
	return &WhipHandler{
		translationManager: translationManager,
		settingEngine:      settingEngine,
	}
}

func (whipHandler *WhipHandler) ServeHTTP(w http.ResponseWriter, request *http.Request) {

	streamKey := getStreamKeyFromAuthHeader(request)

	translation, err := whipHandler.translationManager.GetTranslation(streamKey, nil)
	if checkError("GetTranslation", err, w) {
		return
	}

	// Read the offer from HTTP Request
	offer, err := io.ReadAll(request.Body)
	if checkError("ReadAll", err, w) {
		return
	}

	// TODO: reduce log level or remove
	encodedOffer := string(offer)
	log.Info().Msgf("[DEBUG WHIP] headers: %v", request.Header)
	log.Info().Msgf("[DEBUG WHIP] input stream offer: %v", encodedOffer)

	// Detect reconnection
	// FIXME: reconnect to ICE server if encodedOffer == ""
	if encodedOffer == "" { // Reconnect when OBS studio fail connect to ICE server
		offer = translation.GetOriginObsOffer()
	} else {
		translation.SetOriginObsOffer(offer)
	}

	// Create a MediaEngine object to configure the supported codec
	peerConnection, err := whipHandler.newPeerConnection(w, translation)
	if err != nil {
		return
	}

	// Set a handler for when a new remote track starts, this handler saves buffers to disk as
	// an ivf file, since we could have multiple video tracks we provide a counter.
	// In your application this is where you would handle/process video
	peerConnection.OnTrack(func(track *webrtc.TrackRemote, receiver *webrtc.RTPReceiver) { //nolint: revive

		whipHandler.translationManager.OnOpenStream(streamKey)

	cycle:
		for {
			pkt, _, err := track.ReadRTP()
			if err != nil {
				if checkError("ReadRTP", err, w) {
					break cycle
				}
			}

			for _, remoteTrack := range translation.GetTracks() {
				// Main stream tracks switch
				if remoteTrack.Kind() != track.Kind() {
					continue
				}
				if err = remoteTrack.WriteRTP(pkt); err != nil {
					if checkError("WriteRTP", err, w) {
						break cycle
					}
				}
			}
		}
		whipHandler.translationManager.OnCloseStream(streamKey)
	})

	// Send answer via HTTP Response
	writeAnswer(translation, nil, w, peerConnection, offer, "/whip")
}

func (*WhipHandler) newPeerConnection(w http.ResponseWriter, translation translation.TranslationControl) (*webrtc.PeerConnection, error) {
	m := &webrtc.MediaEngine{}

	// err = m.RegisterDefaultCodecs()
	// if checkError(err, w) {
	// 	return
	// }

	// Setup the codecs you want to use.
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeH264,
			ClockRate:    90000,
			Channels:     0,
			SDPFmtpLine:  "",
			RTCPFeedback: nil,
		},
		PayloadType: 96,
	}, webrtc.RTPCodecTypeVideo); err != nil {
		if checkError("", err, w) {
			return nil, err
		}
	}
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{
			MimeType:     webrtc.MimeTypeOpus,
			ClockRate:    48000,
			Channels:     2,
			SDPFmtpLine:  "minptime=10;useinbandfec=1",
			RTCPFeedback: nil,
		},
		PayloadType: 111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		if checkError("", err, w) {
			return nil, err
		}
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	i := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if checkError("", err, w) {
		return nil, err
	}
	i.Add(intervalPliFactory)

	// Use the default set of Interceptors
	if err = webrtc.RegisterDefaultInterceptors(m, i); err != nil {
		if checkError("", err, w) {
			return nil, err
		}
	}

	// Create the API object with the MediaEngine
	api := webrtc.NewAPI(webrtc.WithMediaEngine(m), webrtc.WithInterceptorRegistry(i))

	// Prepare the configuration

	// Create a new RTCPeerConnection
	peerConnection, err := api.NewPeerConnection(*translation.GetConfiguration())
	if checkError("", err, w) {
		return nil, err
	}

	// Set the handler for Peer connection state
	// This will notify you when the peer has connected/disconnected
	peerConnection.OnConnectionStateChange(func(connectionState webrtc.PeerConnectionState) {
		log.Debug().Msgf("Peer Connection State has changed: %s\n", connectionState.String())

		switch connectionState {

		case webrtc.PeerConnectionStateFailed:
			// Wait until PeerConnection has had no network activity for 30 seconds or another failure. It may be reconnected using an ICE Restart.
			// Use webrtc.PeerConnectionStateDisconnected if you are interested in detecting faster timeout.
			// Note that the PeerConnection may come back from PeerConnectionStateDisconnected.
			log.Error().Msgf("Peer connection has gone to failed exiting, state is %s\n", connectionState.String())
		}
	})
	return peerConnection, err
}
